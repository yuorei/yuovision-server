package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.41

import (
	"context"
	"fmt"
	"time"

	"github.com/yuorei/video-server/app/domain"
	model "github.com/yuorei/video-server/app/domain/models"
	"github.com/yuorei/video-server/graph/generated"
	"github.com/yuorei/video-server/lib"
)

// ID is the resolver for the id field.
func (r *commentResolver) ID(ctx context.Context, obj *model.Comment) (string, error) {
	return obj.ID, nil
}

// Video is the resolver for the video field.
func (r *commentResolver) Video(ctx context.Context, obj *model.Comment) (*model.Video, error) {
	// TODO: Consider adding VideoID field to GraphQL Comment model or implement DataLoader pattern
	// to avoid N+1 query issue. Current implementation requires additional DB query.
	domainComment, err := r.app.Comment.GetComment(ctx, obj.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to get comment for video resolution: %w", err)
	}

	domainVideo, err := r.app.Video.GetVideo(ctx, domainComment.VideoID)
	if err != nil {
		return nil, fmt.Errorf("failed to get video: %w", err)
	}

	return &model.Video{
		ID:                domainVideo.ID,
		VideoURL:          domainVideo.VideoURL,
		Title:             domainVideo.Title,
		ThumbnailImageURL: domainVideo.ThumbnailImageURL,
		Description:       domainVideo.Description,
		Tags:              lib.ConvertStringSliceToPointerSlice(domainVideo.Tags),
		IsPrivate:         domainVideo.IsPrivate,
		IsAdult:           domainVideo.IsAdult,
		IsExternalCutout:  domainVideo.IsExternalCutout,
		WatchCount:        domainVideo.WatchCount,
		CreatedAt:         domainVideo.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
		UpdatedAt:         domainVideo.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"),
		UploaderID:        domainVideo.UploaderID,
		Uploader:          nil,
	}, nil
}

// User is the resolver for the user field.
func (r *commentResolver) User(ctx context.Context, obj *model.Comment) (*model.User, error) {
	// TODO: Consider adding UserID field to GraphQL Comment model or implement DataLoader pattern
	// to avoid N+1 query issue. Current implementation requires additional DB query.
	domainComment, err := r.app.Comment.GetComment(ctx, obj.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to get comment for user resolution: %w", err)
	}
	return r.getUploaderForVideo(ctx, domainComment.UserID)
}

// PostComment is the resolver for the postComment field.
func (r *mutationResolver) PostComment(ctx context.Context, input model.PostCommentInput) (*model.PostCommentPayload, error) {
	userID := r.getCurrentUserID(ctx)
	if userID == "" {
		return nil, fmt.Errorf("user not authenticated")
	}

	// Create domain comment
	comment := &domain.Comment{
		ID:        domain.NewCommentID(),
		VideoID:   input.VideoID,
		UserID:    userID,
		Text:      input.Text,
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}

	// Create comment in database
	if err := r.app.Comment.CreateComment(ctx, comment); err != nil {
		return nil, fmt.Errorf("failed to create comment: %w", err)
	}

	// Store the comment information in context for efficient resolver access
	ctx = context.WithValue(ctx, "comment_"+comment.ID, comment)

	return &model.PostCommentPayload{
		ID:        comment.ID,
		Text:      comment.Text,
		CreatedAt: comment.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
		UpdatedAt: comment.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"),
	}, nil
}

// Video is the resolver for the video field.
func (r *postCommentPayloadResolver) Video(ctx context.Context, obj *model.PostCommentPayload) (*model.Video, error) {
	// Try to get cached comment from context first
	if cachedComment, ok := ctx.Value("comment_" + obj.ID).(*domain.Comment); ok {
		domainVideo, err := r.app.Video.GetVideo(ctx, cachedComment.VideoID)
		if err != nil {
			return nil, fmt.Errorf("failed to get video: %w", err)
		}

		return &model.Video{
			ID:                domainVideo.ID,
			VideoURL:          domainVideo.VideoURL,
			Title:             domainVideo.Title,
			ThumbnailImageURL: domainVideo.ThumbnailImageURL,
			Description:       domainVideo.Description,
			Tags:              lib.ConvertStringSliceToPointerSlice(domainVideo.Tags),
			IsPrivate:         domainVideo.IsPrivate,
			IsAdult:           domainVideo.IsAdult,
			IsExternalCutout:  domainVideo.IsExternalCutout,
			WatchCount:        domainVideo.WatchCount,
			CreatedAt:         domainVideo.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
			UpdatedAt:         domainVideo.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"),
			UploaderID:        domainVideo.UploaderID,
			Uploader:          nil,
		}, nil
	}

	// Fallback to database query if not in context
	domainComment, err := r.app.Comment.GetComment(ctx, obj.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to get comment for video resolution: %w", err)
	}

	domainVideo, err := r.app.Video.GetVideo(ctx, domainComment.VideoID)
	if err != nil {
		return nil, fmt.Errorf("failed to get video: %w", err)
	}

	return &model.Video{
		ID:                domainVideo.ID,
		VideoURL:          domainVideo.VideoURL,
		Title:             domainVideo.Title,
		ThumbnailImageURL: domainVideo.ThumbnailImageURL,
		Description:       domainVideo.Description,
		Tags:              lib.ConvertStringSliceToPointerSlice(domainVideo.Tags),
		IsPrivate:         domainVideo.IsPrivate,
		IsAdult:           domainVideo.IsAdult,
		IsExternalCutout:  domainVideo.IsExternalCutout,
		WatchCount:        domainVideo.WatchCount,
		CreatedAt:         domainVideo.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
		UpdatedAt:         domainVideo.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"),
		UploaderID:        domainVideo.UploaderID,
		Uploader:          nil,
	}, nil
}

// User is the resolver for the user field.
func (r *postCommentPayloadResolver) User(ctx context.Context, obj *model.PostCommentPayload) (*model.User, error) {
	// Try to get cached comment from context first
	if cachedComment, ok := ctx.Value("comment_" + obj.ID).(*domain.Comment); ok {
		return r.getUploaderForVideo(ctx, cachedComment.UserID)
	}

	// Fallback to database query if not in context
	domainComment, err := r.app.Comment.GetComment(ctx, obj.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to get comment for user resolution: %w", err)
	}
	return r.getUploaderForVideo(ctx, domainComment.UserID)
}

// CommentsByVideo is the resolver for the commentsByVideo field.
func (r *queryResolver) CommentsByVideo(ctx context.Context, videoID string) ([]*model.Comment, error) {
	domainComments, err := r.app.Comment.GetCommentsByVideoID(ctx, videoID)
	if err != nil {
		return nil, fmt.Errorf("failed to get comments: %w", err)
	}

	var gqlComments []*model.Comment
	for _, domainComment := range domainComments {
		gqlComment := &model.Comment{
			ID:        domainComment.ID,
			Text:      domainComment.Text,
			CreatedAt: domainComment.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
			UpdatedAt: domainComment.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"),
		}
		gqlComments = append(gqlComments, gqlComment)
	}

	return gqlComments, nil
}

// Comment is the resolver for the comment field.
func (r *queryResolver) Comment(ctx context.Context, id string) (*model.Comment, error) {
	domainComment, err := r.app.Comment.GetComment(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to get comment: %w", err)
	}

	return &model.Comment{
		ID:        domainComment.ID,
		Text:      domainComment.Text,
		CreatedAt: domainComment.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
		UpdatedAt: domainComment.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"),
	}, nil
}

// Comment returns generated.CommentResolver implementation.
func (r *Resolver) Comment() generated.CommentResolver { return &commentResolver{r} }

// PostCommentPayload returns generated.PostCommentPayloadResolver implementation.
func (r *Resolver) PostCommentPayload() generated.PostCommentPayloadResolver {
	return &postCommentPayloadResolver{r}
}

type commentResolver struct{ *Resolver }
type postCommentPayloadResolver struct{ *Resolver }
