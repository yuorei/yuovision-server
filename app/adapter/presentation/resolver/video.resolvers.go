package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.41

import (
	"context"
	"fmt"

	model "github.com/yuorei/video-server/app/domain/models"
	"github.com/yuorei/video-server/graph/generated"
	"github.com/yuorei/video-server/lib"
)

// UploadVideo is the resolver for the UploadVideo field.
func (r *mutationResolver) UploadVideo(ctx context.Context, input model.UploadVideoInput) (*model.VideoPayload, error) {
	panic(fmt.Errorf("not implemented: UploadVideo - UploadVideo"))
}

// IncrementWatchCount is the resolver for the IncrementWatchCount field.
func (r *mutationResolver) IncrementWatchCount(ctx context.Context, input model.IncrementWatchCountInput) (*model.IncrementWatchCountPayload, error) {
	panic(fmt.Errorf("not implemented: IncrementWatchCount - IncrementWatchCount"))
}

// Videos is the resolver for the videos field.
func (r *queryResolver) Videos(ctx context.Context) ([]*model.Video, error) {
	domainVideos, err := r.app.Video.GetVideos(ctx)
	if err != nil {
		return nil, err
	}

	var gqlVideos []*model.Video
	for _, domainVideo := range domainVideos {
		gqlVideo := &model.Video{
			ID:                domainVideo.ID,
			VideoURL:          domainVideo.VideoURL,
			Title:             domainVideo.Title,
			ThumbnailImageURL: domainVideo.ThumbnailImageURL,
			Description:       domainVideo.Description,
			Tags:              lib.ConvertStringSliceToPointerSlice(domainVideo.Tags),
			IsPrivate:         domainVideo.IsPrivate,
			IsAdult:           domainVideo.IsAdult,
			IsExternalCutout:  domainVideo.IsExternalCutout,
			WatchCount:        domainVideo.WatchCount,
			CreatedAt:         domainVideo.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
			UpdatedAt:         domainVideo.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"),
			Uploader:          nil, // Will be resolved by the uploader field resolver
		}
		gqlVideos = append(gqlVideos, gqlVideo)
	}

	return gqlVideos, nil
}

// Video is the resolver for the video field.
func (r *queryResolver) Video(ctx context.Context, id string) (*model.Video, error) {
	panic(fmt.Errorf("not implemented: Video - video"))
}

// WatchCount is the resolver for the watchCount field.
func (r *queryResolver) WatchCount(ctx context.Context, videoID string) (int, error) {
	panic(fmt.Errorf("not implemented: WatchCount - watchCount"))
}

// CutVideo is the resolver for the cutVideo field.
func (r *queryResolver) CutVideo(ctx context.Context, input model.CutVideoInput) (*model.CutVideoPayload, error) {
	panic(fmt.Errorf("not implemented: CutVideo - cutVideo"))
}

// ID is the resolver for the id field.
func (r *videoResolver) ID(ctx context.Context, obj *model.Video) (string, error) {
	panic(fmt.Errorf("not implemented: ID - id"))
}

// Uploader is the resolver for the uploader field.
func (r *videoResolver) Uploader(ctx context.Context, obj *model.Video) (*model.User, error) {
	panic(fmt.Errorf("not implemented: Uploader - uploader"))
}

// ID is the resolver for the id field.
func (r *videoPayloadResolver) ID(ctx context.Context, obj *model.VideoPayload) (string, error) {
	panic(fmt.Errorf("not implemented: ID - id"))
}

// Uploader is the resolver for the uploader field.
func (r *videoPayloadResolver) Uploader(ctx context.Context, obj *model.VideoPayload) (*model.User, error) {
	panic(fmt.Errorf("not implemented: Uploader - uploader"))
}

// Video returns generated.VideoResolver implementation.
func (r *Resolver) Video() generated.VideoResolver { return &videoResolver{r} }

// VideoPayload returns generated.VideoPayloadResolver implementation.
func (r *Resolver) VideoPayload() generated.VideoPayloadResolver { return &videoPayloadResolver{r} }

type videoResolver struct{ *Resolver }
type videoPayloadResolver struct{ *Resolver }
