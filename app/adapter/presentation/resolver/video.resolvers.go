package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.41

import (
	"context"
	"io"

	"github.com/yuorei/video-server/app/domain"
	model "github.com/yuorei/video-server/app/domain/models"
	"github.com/yuorei/video-server/graph/generated"
)

// UploadVideo is the resolver for the UploadVideo field.
func (r *mutationResolver) UploadVideo(ctx context.Context, input model.UploadVideoInput) (*model.VideoPayload, error) {
	var thumbnailImage *io.ReadSeeker
	var thumbnailImageContentType string

	if input.ThumbnailImage != nil {
		thumbnailImage = &input.ThumbnailImage.File
		thumbnailImageContentType = input.ThumbnailImage.ContentType
	}

	videoID := domain.NewVideoID()
	uploadVideo := domain.NewUploadVideo(videoID, input.Video.File, input.Video.ContentType, thumbnailImage, thumbnailImageContentType, input.Title, input.Description)

	uploadedVideo, err := r.usecase.UploadVideo(ctx, uploadVideo)
	if err != nil {
		return nil, err
	}

	return &model.VideoPayload{
		ID:                uploadedVideo.ID,
		VideoURL:          uploadedVideo.VideoURL,
		ThumbnailImageURL: uploadedVideo.ThumbnailImageURL,
		Title:             uploadedVideo.Title,
		Description:       uploadedVideo.Description,
		CreatedAt:         uploadedVideo.CreatedAt.String(),
		UpdatedAt:         uploadedVideo.CreatedAt.String(),
	}, nil
}

// Videos is the resolver for the videos field.
func (r *queryResolver) Videos(ctx context.Context) ([]*model.Video, error) {
	videos, err := r.usecase.GetVideos(ctx)
	if err != nil {
		return nil, err
	}

	var result []*model.Video
	for _, video := range videos {
		result = append(result, &model.Video{
			ID:                video.ID,
			VideoURL:          video.VideoURL,
			ThumbnailImageURL: video.ThumbnailImageURL,
			Title:             video.Title,
			Description:       video.Description,
			CreatedAt:         video.CreatedAt.String(),
			UpdatedAt:         video.CreatedAt.String(),
			Uploader: &model.User{
				ID: video.UploaderID,
			},
		})
	}

	return result, nil
}

// Video is the resolver for the video field.
func (r *queryResolver) Video(ctx context.Context, id string) (*model.Video, error) {
	video, err := r.usecase.GetVideo(ctx, id)
	if err != nil {
		return nil, err
	}
	return &model.Video{
		ID:                video.ID,
		VideoURL:          video.VideoURL,
		ThumbnailImageURL: video.ThumbnailImageURL,
		Title:             video.Title,
		Description:       video.Description,
		CreatedAt:         video.CreatedAt.String(),
		UpdatedAt:         video.CreatedAt.String(),
		Uploader: &model.User{
			ID: video.UploaderID,
		},
	}, nil
}

// ID is the resolver for the id field.
func (r *videoResolver) ID(ctx context.Context, obj *model.Video) (string, error) {
	return obj.ID, nil
}

// Uploader is the resolver for the uploader field.
func (r *videoResolver) Uploader(ctx context.Context, obj *model.Video) (*model.User, error) {
	user, err := r.usecase.GetUser(ctx, obj.Uploader.ID)
	if err != nil {
		return nil, err
	}
	return &model.User{
		ID:   obj.Uploader.ID,
		Name: user.Name,
	}, nil
}

// ID is the resolver for the id field.
func (r *videoPayloadResolver) ID(ctx context.Context, obj *model.VideoPayload) (string, error) {
	return obj.ID, nil
}

// Uploader is the resolver for the uploader field.
func (r *videoPayloadResolver) Uploader(ctx context.Context, obj *model.VideoPayload) (*model.User, error) {
	return &model.User{}, nil
}

// Video returns generated.VideoResolver implementation.
func (r *Resolver) Video() generated.VideoResolver { return &videoResolver{r} }

// VideoPayload returns generated.VideoPayloadResolver implementation.
func (r *Resolver) VideoPayload() generated.VideoPayloadResolver { return &videoPayloadResolver{r} }

type videoResolver struct{ *Resolver }
type videoPayloadResolver struct{ *Resolver }
